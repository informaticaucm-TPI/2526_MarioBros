# √çndice

- [Pr√°ctica 2 - Parte II: Mario Extended](#pr√°ctica-2---parte-ii-mario-extended)
- [AddObjectCommand y factor√≠a de objetos](#AddObjectCommand-y-factor√≠a-de-objetos)
  - [Formato de los objetos del juego](#formato-de-objetos-del-juego)
  - [Factor√≠a de objetos](#factory)
  - [Comando `AddObjectCommand`](#comando-addobjectcommand)
	- [Nuevo nivel para crear escenarios](#draw-map)
- [Nuevos objetos: Box y Mushroom](#box-mushroom)
  - [Mushroom](#mushroom)
  - [Box](#box)
- [Pruebas](#pruebas)
- [Entrega](#entrega)
  
<!-- TOC end -->
<!-- TOC --><a name="pr√°ctica-2-parte-ii-mario-extended"></a>
# Pr√°ctica 2 - Parte II: Mario Extended

**Entrega: Semana del 17 de noviembre**

**Objetivos:** Herencia, polimorfismo, clases abstractas e interfaces.

**Preguntas Frecuentes**: Como es habitual que teng√°is dudas (es normal) las iremos recopilando en este [documento de preguntas frecuentes](../faq.md). Para saber los √∫ltimos cambios que se han introducido [puedes consultar la historia del documento](https://github.com/informaticaucm-TPI/2425-Lemmings/commits/main/enunciados/faq.md).

En esta pr√°ctica vamos a extender el c√≥digo con nuevas funcionalidades. El principal objetivo de esta pr√°ctica ser√° a√±adir nuevos objetos y nuevos comandos al juego. 

Antes de comenzar, tened en cuenta la **advertencia**:

> La falta de encapsulaci√≥n, el uso de m√©todos que devuelvan listas, y el uso de `instanceof` o `getClass()` (fuera de metodos ``equals(Object other)``) tiene como consecuencia un **suspenso directo** en la pr√°ctica. Es incluso peor implementar un `instanceof` casero, por ejemplo as√≠: cada subclase de la clase `GameObject` contiene un conjunto de m√©todos `esX`, uno por cada subclase X de `GameObject`; el m√©todo `esX` de la clase X devuelve `true` y los dem√°s m√©todos `esX` de la clase X devuelven `false`.


<!-- TOC --><a name="AddObjectCommand-y-factor√≠a-de-objetos"></a>

# AddObjectCommand y factor√≠a de objetos

Nos planteamos realizar una extensi√≥n in√©dita en Mario, inspirada en juegos como Minecraft.
La extensi√≥n consiste en permitir que los usuarios creativos puedan crear sus propios mapas o modificar los ya existentes, y jugar en ellos. Es decir, a√±adiremos el *modo creativo* al juego de Mario.

Para ello ser√° necesario crear una factor√≠a de objetos, replicando la t√©cnica de la factor√≠a de comandos, un nuevo comando ``AddObjectCommand``, y adem√°s de un mapa, para poder generar cualquier escenario.

<!-- TOC --><a name="formato-de-objetos-del-juego"></a>
## Formato de los objetos del juego

Antes de hablar sobre el comando ``AddObjectCommand``, hemos de saber que para poder a√±adir un objeto al ``Game`` desde un ``String`` es necesario establecer un formato sobre los datos contenidos en  dicho ``String``. A continuaci√≥n vamos a explicar el formato mediante unos ejemplos sencillos. 

El siguiente ejemplo representa un array de Strings, donde cada ``String`` representa a un objeto:

````
String[] a = {
    "(1,2) MARIO RIGHT BIG",
    "(0,1) LAND",
    "(3,2) GOOMBA RIGHT",
    "(2,7) EXITDOOR"
};
````

En primer lugar tenemos:
````
"(1,2) MARIO RIGHT BIG"
```` 
que se corresponde con un Mario situado en la fila 1, columna 2. Con direcci√≥n paso derecha; ``RIGHT``(la direcci√≥n, en este caso, solo podr√≠a ser o ``LEFT`` o ``RIGHT`` o ``STOP``, y aunque est√© en el aire, ser√° importante de cara a c√≥mo se dibuja el Mario y a qu√© direcci√≥n va a utilizar una vez deje de estar en el aire). Por √∫ltimo aparece el valor ``BIG``  que indica que es grande (``isBig = true``), para indicar que no es grande, en lugar de un ``BIG`` tendr√≠amos un ``SMALL``. Tambi√©n se deber√≠a poder crear un Mario con ``(1,2) MARIO`` que lo crear√≠a en sus valores por defecto que son ``RIGHT`` y ``BIG``, o ``(1,2) MARIO LEFT`` que crear√≠a un Mario con direcci√≥n de paso hacia la izquierda y grande.

En la siguiente posici√≥n tenemos 

````
   "(0,1) LAND",
````
esto nos indica que en la fila 0 columna 1, hay un Land. 

Seguidamente, tenemos que 
````
"(3,2) GOOMBA RIGHT",
````
indica que hay un Goomba en la fila 3 columna 2 cuya direcci√≥n de paso es derecha. Tambi√©n se debe permitir una l√≠nea del tipo ``(3,2) GOOMBA`` que a√±adir√≠a un Goomba en su direcci√≥n por defecto ``LEFT``

Y finalmente tenemos:
````
 "(2,7) EXITDOOR"
````
que representa una puerta de salida en la fila 2 columna 2. 

Como pod√©is observar, en todos los casos el patr√≥n es muy simple:
````
    posicionDelObjeto tipoDeObjeto atributosDelObjeto
````

Adem√°s, se ha de tener en cuenta que para los objetos se podr√°n usar sus variantes cortas (``M``, ``G``, ``L`` y ``ED`` para ``Mario``, ``Goomba``, ``Land``  y ``ExitDoor`` respectivamente. Pudiendo tambi√©n utilizar las abreviaturas ``L`` y ``R``para las acciones ``LEFT`` y ``RIGHT`` respectivamente, y ``B`` y ``S``para los tama√±os de Mario ``BIG`` y ``SMALL`` respectivamente.

<!-- TOC --><a name="factory"></a>
## Factor√≠a de objetos

A continuaci√≥n, tendremos que a√±adir una **factor√≠a** de objetos a nuestra pr√°ctica. Como ya hemos visto para los comandos, la factor√≠a se encarga de separar la l√≥gica de la creaci√≥n de un objeto del lugar en el que se crea.

Esta factor√≠a estar√° implementada mediante una clase ``GameObjectFactory`` en el paquete ``gameobjects`` con un m√©todo 

```java
	public static GameObject parse (String objWords[], GameWorld game);
```
Usando esta factor√≠a, para crear un objeto cuyas caracter√≠sticas vengan dadas por un array de Strings ``objWords``, bastar√≠a hacer:

```java
GameObject gameobject = GameObjectFactory.parse(String objWords[], GameWorld game);
```

Fijaos que al crear el objeto no conocemos cu√°l es su tipo. La implementaci√≥n de este m√©todo seguir√° una estructura similar a la del m√©todo ``parse`` de ``CommandGenerator``. ``GameObjectFactory`` mantendr√° una lista de objetos disponibles, al igual que hac√≠a ``CommandGenerator`` con los comandos:

```java
private static final List<GameObject> availableObjects = Arrays.asList(
	new Land(),
	new ExitDoor(),
	new Goomba(),
	new Mario(),
	......
);
```
El m√©todo ``parse()`` deber√°, a su vez, llamar a otro m√©todo ``parse`` desde cada objeto de la lista. Si la descripci√≥n dada por ``objWords`` se corresponde con alg√∫n objeto, deber√° devolver una instancia de dicho objeto con las caracter√≠sticas indicadas. Si no se corresponde con ninguno, deber√° devolver ``null``.  Podr√° existir un m√©todo ``parse`` en la clase ``GameObject`` que ser√° sobreescrito en las clases de aquellos objetos menos sencillos. 

Observa que para crear los objetos en la lista `availableObjects` necesitamos que estos tengan un constructor sin argumentos. ¬øQu√© modificador de acceso necesita dicho constructor?


<!-- TOC --><a name="comando-addobjectcommand"></a>
## AddObjectCommand
A continuaci√≥n, vamos a definir un comando, ``AddObjectCommand``, el cual va a posibilitar que el usuario pueda a√±adir un objeto/personaje de cualquier tipo en cualquier posici√≥n del tablero. Las principales caracter√≠sticas del mismo son las siguientes:


````
Nombre: addObject
Abreviatura: aO
Detalles: [a]dd[O]bject <object_description>
Ayuda: adds to the board the object given by object_description
````

- El argumento `<object_description>` del comando es obligatorio y se corresponde con una l√≠nea de objeto que deber√° seguir el formato indicado al comienzo de esta secci√≥n.
- Por ejemplo, al ejecutar `ao (14,3) Land` se a√±adir√° un objeto `Land` en `(14,3)`. Y al ejecutar ``aO (13,3) Goomba RIGHT`` se a√±adir√° en la posici√≥n ``(13,3)`` un objeto ``Goomba`` cuya direcci√≥n de paso es ``RIGHT``.  
- Si la descripci√≥n del objeto no se puede parsear o la posici√≥n dada est√° fuera del tablero, el comando mostrar√° el siguiente mensaje de error: ``Invalid game object: <stringObjeto>``.
- Para parsear el comando o lanzar el mensaje de error te resultar√°n de utilidad los siguientes m√©todos:
	- `Arrays.copyOfRange(words, from, to)`: devuelve una copia del array `words` desde el √≠ndice `from` (incluido) a `to` (excluido).
	- `String.join(" ", words)`: devuelve un `String` construido juntando los strings del array `words`, separ√°ndolos mediante espacios.

<!-- TOC --><a name="draw-map"></a>
### Nuevo nivel para crear escenarios

Para poder crear escenarios desde cero usando este comando, habr√° que crear un nuevo nivel ``-1`` en el juego. Este nivel ser√° un mapa vac√≠o con 3 vidas, 100 unidades de tiempo y 0 puntos. Este mapa, a diferencia de los anteriormente vistos, incluye las vidas. Por tanto, cuando se resetee este mapa, tambi√©n se resetear√° el n√∫mero de vidas a 3. 
![mapa-1](imgs/mapa-1.png)

<!-- TOC --><a name="#box-mushroom"></a>
# Nuevos objetos: Box y Mushroom

Ahora que ya tenemos nuestra factor√≠a de objetos, adem√°s de la clase ``GameObject`` que nos permite utilizar el polimorfismo, vamos a a√±adir al juego un par de nuevos objetos. Estos ser√°n la t√≠pica caja del juego de Mario ``Box`` y la seta que convierte a Mario de peque√±o a grande ``MushRoom``.

<!-- TOC --><a name="mushroom"></a>
## Mushroom
Las caracter√≠sticas de este objeto ser√°n  las siguientes:
````
Nombre: Mushroom
Abreviatura: MU
Icono: üçÑ
````

Este objeto representar√° a la cl√°sica seta del juego de Mario. Ser√° representado por el icono **üçÑ**. Se considera un objeto no s√≥lido. Este objeto interactuar√° con ``Mario``, si se encuentra en la misma posici√≥n que este, de la siguiente forma: si ``Mario`` es grande, el ``Mushroom`` desaparece y si ``Mario`` es peque√±o se hace grande y el ``Mushroom`` desaparece. Con el resto de objetos no mantiene ninguna interacci√≥n. A diferencia de los `Goombas` la seta se dirige inicalmente a la derecha para que a `Mario` le resulte m√°s dif√≠cil cogerla.

<!-- TOC --><a name="box"></a>
## Box
Finalmente, a√±adiremos un objeto que representar√° a la cl√°sica caja de Mario. Las caracter√≠sticas principales del objeto son las siguientes:
````
Nombre: Box
Abreviatura: B
Icono: ? (si a√∫n no ha sido abierto) y 0 (si ya se ha abierto)
Puntos: 50
````
Este objeto se considera un objeto s√≥lido y no movible. En la primera colisi√≥n **desde abajo** entre Mario y la caja, aparecer√° un ``MushRoom``, la caja se vaciar√° y dar√° a Mario 50 puntos. Para las dem√°s interacciones con cualquier objeto esta actuar√° como un ``Land`` y, por tanto, no se llevar√° a cabo ninguna acci√≥n.

En la vista con colores est√° ya implementado de la siguiente forma: Si la caja no est√° vac√≠a se representar√° con el icono **?** sobre un fondo gris, mientras que si la caja s√≠ est√° vac√≠a, se representar√° √∫nicamente con un fondo gris. 

Para probar estas estensiones crear un nuevo nivel ``2`` que sea exactamente igual el nivel ``1`` pero con una caja en la posici√≥n `(9,4)` y dos setas en las posiciones `(12,8)` y `(2,20)`. Las posiciones indicadas siguen el formato: ``(fila,columna)``.

Ten en cuenta que tambi√©n puedes probar dichos objetos a trav√©s del comando definido antes ``AddObjectCommand``.

<!-- TOC --><a name="pruebas"></a>
## Pruebas

Junto con este enunciado se acaban de a√±adir al GitHub las pruebas de estas extensiones (clase `tp1.Tests_V2_2`). Recuerda que t√∫ c√≥digo debe pasarlas. Para realizar estas pruebas, incluye a tu proyecto dicho fichero y la carpeta `tests/pr2_2`


<!-- TOC --><a name="entrega"></a>
## Entrega
La pr√°ctica debe entregarse utilizando el mecanismo de entregas del campus virtual, no m√°s tarde de la **fecha y hora indicada en la tarea del campus virtual**.

El fichero debe tener, al menos, el siguiente contenido [^1]:

- Directorio `tp1` con el c√≥digo de todas las clases de la pr√°ctica.
- Fichero `alumnos.txt` donde se indicar√° el nombre de los componentes del grupo.

Recuerda que no se deben incluir los `.class`.

> **Nota**: Recuerda que puedes utilizar la opci√≥n `File > Export` para ayudarte a generar el .zip.

[^1]: Puedes incluir tambi√©n opcionalmente los ficheros de informaci√≥n del proyecto de Eclipse

